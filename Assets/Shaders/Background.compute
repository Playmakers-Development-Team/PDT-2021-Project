#include "Background.cginc"

#pragma kernel line_occlusion
[numthreads(8,8,1)]
void line_occlusion (const uint3 id : SV_DispatchThreadID)
{
    const float2 uv = pixel_to_uv(id.xy, get_output_resolution());

    const float4 input = tex2Dlod(_input, float4(uv, 0, 0));
    const float brightness = input.r;

    output[id.xy] = float4(1, 1, 1, brightness);
}

#pragma kernel displacement
[numthreads(8, 8, 1)]
void displacement (const uint3 id : SV_DispatchThreadID)
{
    const float2 resolution = get_output_resolution();
    const float2 uv = pixel_to_uv(id.xy, resolution);

    float2 displacement_value = sample_params(_tex1, uv, displacement_in[0].texture_params).rg;
    displacement_value = displacement_value * 2 - 1;
    displacement_value *= displacement_in[0].amount;

    output[id.xy] = tex2Dlod(_input, float4(uv + displacement_value, 0, 0)); 
}

#pragma kernel opacity_extraction
[numthreads(8, 8, 1)]
void opacity_extraction (const uint3 id : SV_DispatchThreadID)
{
    const float2 resolution = get_output_resolution();
    const float2 uv = pixel_to_uv(id.xy, resolution);

    const float4 samp = tex2Dlod(_input, float4(uv, 0, 0));
    float opacity = saturate(1.0 - max(samp.r, max(samp.g, samp.b)));
    if (opacity > 0)
        opacity += opacity_extraction_in[0].exposure * samp.a;
    
    output[id.xy] = float4(samp.rgb, opacity);
}

#pragma kernel edge_detection
[numthreads(8, 8, 1)]
void edge_detection (const uint3 id : SV_DispatchThreadID)
{
    const float2 resolution = get_output_resolution();
    const float2 uv = pixel_to_uv(id.xy, resolution);

    const float4 input = tex2Dlod(_input, float4(uv, 0, 0));

    for (uint i = 0; i < edge_detection_in[0].radius; i++)
    {
        for (uint j = 0; j < 9; j++)
        {
            const float2 offset = offsets[j] * (i + 1);
            const float2 offset_uv = uv + pixel_to_uv(offset, resolution);
            
            const float4 value = tex2Dlod(_input, float4(offset_uv, 0, 0));
            const float4 diff = abs(value - input);
            
            if (max(diff.r, max(diff.g, diff.b)) < edge_detection_in[0].threshold)
                continue;
            
            output[id.xy] = float4(uv, 0, 1);
            return;
        }
    }
    
    output[id.xy] = 0;
}

#pragma kernel jump_flood
[numthreads(8, 8, 1)]
void jump_flood (const uint3 id : SV_DispatchThreadID)
{
    const float2 resolution = get_output_resolution();
    const float2 uv = pixel_to_uv(id.xy, resolution);

    float4 final_value = 0;
    float max_dist = 1;

    for (int i = 0; i < 9; i++)
    {
        const float2 offset = offsets[i] * jump_flood_in[0].step_size;
        const uint2 neighbour_id = id.xy + offset;
        
        const float4 neighbour = tex2Dlod(_input, float4(pixel_to_uv(neighbour_id, resolution), 0, 0));

        if (neighbour.a <= 0)
            continue;

        const float dist = distance(neighbour.rg, uv) / root_two;

        if (dist < max_dist)
        {
            max_dist = dist;
            final_value = float4(neighbour.rg, 0, dist);
        }
    }

    output[id.xy] = final_value;
}

#pragma kernel colour_separation
[numthreads(8, 8, 1)]
void colour_separation (const uint3 id : SV_DispatchThreadID)
{
    const float2 resolution = get_output_resolution();
    const float2 uv = pixel_to_uv(id.xy, resolution);
    
    const float distance_field_value = smoothstep(0, .01, tex2Dlod(_tex1, float4(uv, 0, 0)).a);

    const float strength = sample_params(_tex2, uv, colour_separation_in[0].strength_params).r;

    // TODO: Implement a smoother transition...
    if (distance_field_value < colour_separation_in[0].amount * pow(strength, 2))
        output[id.xy] = 0;
}